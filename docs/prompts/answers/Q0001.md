# Q0001: MVVM, MVI에 대해 설명해줘

**날짜**: 2026-02-27
**원본**: [PROPMTS.md](../PROPMTS.md#q0001)

## 질문

1. Flutter에서도 MVVM, MVI 패턴을 사용해?
2. 더 선호되고 많이 사용되는 패턴은 뭐야?
3. 현재 이 프로젝트에는 어떤 패턴이 더 적합해 보여?

## 답변

### 1. Flutter에서도 MVVM, MVI 패턴을 사용해?

**네, 사용합니다.** 다만 Android/iOS 네이티브와는 구현 방식이 조금 다릅니다.

#### MVVM (Model-View-ViewModel)

```
View (Widget)
  ↕  observe state / call methods
ViewModel (Notifier/ChangeNotifier)
  ↕  call use cases
Model (Entity/State)
```

- **View**: Flutter Widget. ViewModel의 상태를 구독하고 UI를 그립니다.
- **ViewModel**: 비즈니스 로직 처리 + UI 상태 관리. View를 직접 참조하지 않습니다.
- **Model**: 데이터 구조 (Entity, DTO 등)

Flutter에서는 Riverpod의 `NotifierProvider`, `AsyncNotifierProvider` 또는 `ChangeNotifier`로 ViewModel을 구현합니다.

```dart
// ViewModel
@riverpod
class CalculatorViewModel extends _$CalculatorViewModel {
  @override
  CalculatorState build() => CalculatorState.initial();

  void pressNumber(String number) {
    state = state.copyWith(input: state.input + number);
  }

  void calculate() {
    final result = _evaluate(state.input);
    state = state.copyWith(result: result);
  }
}

// View
class CalculatorScreen extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(calculatorViewModelProvider);
    return Text(state.result);
  }
}
```

---

#### MVI (Model-View-Intent)

```
View (Widget)
  → Intent (사용자 액션)
  → ViewModel/Store (Intent 처리)
  → State (불변 상태)
  → View (리렌더링)
```

**단방향 데이터 흐름(Unidirectional Data Flow)** 이 핵심입니다.

- **Intent**: 사용자가 의도한 액션 (버튼 클릭, 텍스트 입력 등) — sealed class로 표현
- **State**: 불변(immutable) UI 상태 — Freezed로 표현
- **Model**: Intent를 받아 새 State를 계산하고 방출

```dart
// Intent (사용자 액션 정의)
sealed class CalculatorIntent {
  const factory CalculatorIntent.pressNumber(String number) = PressNumber;
  const factory CalculatorIntent.pressOperator(String op) = PressOperator;
  const factory CalculatorIntent.calculate() = Calculate;
  const factory CalculatorIntent.clear() = Clear;
}

// State (불변 UI 상태)
@freezed
class CalculatorState with _$CalculatorState {
  const factory CalculatorState({
    required String display,
    required bool hasError,
  }) = _CalculatorState;

  factory CalculatorState.initial() => const CalculatorState(
    display: '0',
    hasError: false,
  );
}

// ViewModel (Intent → 새 State 계산)
@riverpod
class CalculatorViewModel extends _$CalculatorViewModel {
  @override
  CalculatorState build() => CalculatorState.initial();

  void handleIntent(CalculatorIntent intent) {
    state = switch (intent) {
      PressNumber(:final number) => _onPressNumber(number),
      PressOperator(:final op)   => _onPressOperator(op),
      Calculate()                => _onCalculate(),
      Clear()                    => CalculatorState.initial(),
    };
  }
}

// View
class CalculatorScreen extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(calculatorViewModelProvider);
    final vm = ref.read(calculatorViewModelProvider.notifier);

    return Column(
      children: [
        Text(state.display),
        ElevatedButton(
          onPressed: () => vm.handleIntent(const CalculatorIntent.calculate()),
          child: const Text('='),
        ),
      ],
    );
  }
}
```

---

### 2. 더 선호되고 많이 사용되는 패턴은?

Flutter 생태계에서의 현황:

| 패턴 | 사용률 | 주요 라이브러리 | 특징 |
|------|--------|----------------|------|
| **MVVM** | ★★★★★ 가장 많음 | Riverpod + Notifier | 진입장벽 낮음, 유연함 |
| **BLoC** | ★★★★ 많음 | flutter_bloc | 엄격한 구조, 대형 팀에 적합 |
| **MVI** | ★★★ 중간 | Riverpod + sealed class | MVVM 위에 Intent 개념 추가 |
| **Redux** | ★★ 적음 | flutter_redux | 복잡, 보일러플레이트 많음 |

**결론**: **MVVM이 가장 많이 사용됩니다.** 특히 Riverpod과 조합하면 간결하고 테스트하기 쉬운 코드가 나옵니다. MVI는 MVVM의 발전형으로, 대규모 앱이나 팀에서 일관성을 위해 채택하는 경우가 늘고 있습니다.

---

### 3. 현재 CalcMate 프로젝트에 더 적합한 패턴은?

현재 프로젝트 상황:
- Riverpod 도입 예정
- Clean Architecture 계획 (Data / Domain / Presentation)
- 계산기 앱 (상태 전환이 명확하고 예측 가능)
- Freezed 도입 예정

**추천: MVVM + MVI 스타일의 Intent 패턴**

두 패턴의 장점을 합친 방식입니다:

```
sealed class CalculatorIntent   ← MVI의 명확한 액션 정의
CalculatorState (Freezed)       ← MVI의 불변 상태
CalculatorViewModel (Riverpod)  ← MVVM의 ViewModel
```

이유:
1. **계산기 특성상 액션이 명확** (숫자 입력, 연산자, 초기화, 계산) → `sealed class`로 표현하면 누락 없이 처리 가능
2. **Riverpod + Freezed** 조합이 이미 계획되어 있어 추가 비용 없음
3. **테스트 용이** — ViewModel에 Intent를 넣고 State를 검증하면 됨
4. **단순한 단방향 흐름** — 버그 추적이 쉬움

MVVM 단독은 메서드 호출이 자유로워 큰 프로젝트에서 흐름 파악이 어려워질 수 있는데, Intent 패턴을 추가하면 "어떤 액션이 존재하는지"를 코드로 강제할 수 있습니다.
